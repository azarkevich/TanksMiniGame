#include "StdAfx.h"
#include "Tank.h"
#include "World.h"
#include "Bullet.h"

Tank::Tank(World *w, int tank_type, int x, int y, int armo)
{
	X = x;
	Y = y;
	_world = w;
	_orients[ORIENT_UP] = new Sprite();
	_orients[ORIENT_DOWN] = new Sprite();
	_orients[ORIENT_LEFT] = new Sprite();
	_orients[ORIENT_RIGHT] = new Sprite();
	if(tank_type == TANK_PLAYER)
	{
		_orients[ORIENT_UP]->load(TilesCache::main, "resources/tank-a-up.sprite");
		_orients[ORIENT_DOWN]->load(TilesCache::main, "resources/tank-a-down.sprite");
		_orients[ORIENT_LEFT]->load(TilesCache::main, "resources/tank-a-left.sprite");
		_orients[ORIENT_RIGHT]->load(TilesCache::main, "resources/tank-a-right.sprite");
	}
	else if(tank_type == TANK_ENIMY)
	{
		_orients[ORIENT_UP]->load(TilesCache::main, "resources/tank-b-up.sprite");
		_orients[ORIENT_DOWN]->load(TilesCache::main, "resources/tank-b-down.sprite");
		_orients[ORIENT_LEFT]->load(TilesCache::main, "resources/tank-b-left.sprite");
		_orients[ORIENT_RIGHT]->load(TilesCache::main, "resources/tank-b-right.sprite");
	}

	_orients_bb[ORIENT_UP] = BounceBox(4, 2, 24, 28);
	_orients_bb[ORIENT_DOWN] = BounceBox(4, 2, 24, 28);
	_orients_bb[ORIENT_LEFT] = BounceBox(2, 4, 28, 24);
	_orients_bb[ORIENT_RIGHT] = BounceBox(2, 4, 28, 24);

	Orient = ORIENT_UP;
	sprite = _orients[Orient];
	BBox = _orients_bb[Orient];
	InitialArmour = Armour = armo;
	
	BulletArmour = 0;
	
	TankSpeed = 32;
}

void Tank::fire()
{
	int ex = X, ey = Y;
	if(Orient == ORIENT_UP || Orient == ORIENT_DOWN)
		ex = X + BBox.x + BBox.w/2;

	if(Orient == ORIENT_LEFT || Orient == ORIENT_RIGHT)
		ey = Y + BBox.y + BBox.h/2;

	if(Orient == ORIENT_DOWN)
		ey += BBox.h;

	if(Orient == ORIENT_RIGHT)
		ex += BBox.w;

	Bullet *b = new Bullet(_world, Orient, ex, ey, this);
	b->set_armour(BulletArmour);
	_world->add_object(b);
}

void Tank::draw(SDL_Surface *s)
{
	sprite->draw(s, X, Y);

	if(!is_remove_pending())
	{
		SDL_Rect r;
		r.x = X - 5;
		r.y = Y - 5;
		if(r.x > 0 && r.y > 0)
		{
			r.w = 5 + (InitialArmour * 5);
			r.h = 4;
			SDL_FillRect(s, &r, SDL_MapRGB(s->format, 0, 0, 0));
			r.x++;
			r.y++;
			r.h-=2;
			r.w-=2;
			SDL_FillRect(s, &r, SDL_MapRGB(s->format, 255, 0, 0));
			if(Armour > 0 && InitialArmour > 0)
			{
				r.w = r.w * (1.0 * Armour / InitialArmour);
				SDL_FillRect(s, &r, SDL_MapRGB(s->format, 0, 255, 0));
			}
		}
	}
}

void Tank::think()
{
	sprite->think();
	if(_world->_player != this && _world->EnvMapChanged)
	{
		think_strategey();
	}
}

bool Tank::is_can_goto(int row, int col)
{
	int type = OBJ_NONE;
	if(_world->EnvMap[row][col] != NULL)
		type = _world->EnvMap[row][col]->type();
	
	if(type == OBJ_WALL || type == OBJ_TANK || type == OBJ_FLAG || type == OBJ_GUN)
		return false;
	
	return true;
}

void Tank::think_strategey()
{
	cout << "Recalc Strategy " << endl;
	vector< vector<int > > paths(_world->EnvMap.size(), vector<int>(_world->EnvMap[0].size(), -1));
	// flag
	int flag_row = -1;
	int flag_col = -1;
	// my cell:
	int col = X/32;
	int row = Y/32;
	paths[row][col] = 0;
	int step = 0;
	bool path_added = true;
	while(path_added)
	{
		path_added = false;
//		show_wave(step, paths);
		for(unsigned int i=0;i<paths.size();i++)
		{
			for(unsigned int j=0;j<paths[i].size();j++)
			{
				if(paths[i][j] != step)
					continue;
				
				// can't go from this point. skip
				if(is_can_goto(i, j) == false)
					continue;
				
				if(flag_col == -1 && flag_row == -1 && _world->EnvMap[i][j] == _world->player_flag)
				{
					flag_col = j;
					flar_row = i;
				}
				
				// free to step up
				if(i > 0 && is_can_goto(i-1, j) && paths[i-1][j] == -1)
				{
					paths[i-1][j] = step+1;
				}
				// free to step down
				if(i < (paths.size()-1) && is_can_goto(i+1, j) && paths[i+1][j] == -1)
				{
					paths[i+1][j] = step+1;
				}
				// free to step left
				if(j > 0 && is_can_goto(i, j-1) && paths[i][j-1] == -1)
				{
					paths[i][j-1] = step+1;
				}
				// free to step right
				if(j < (paths[i].size() - 1) && is_can_goto(i, j+1) && paths[i][j+1] == -1)
				{
					paths[i][j+1] = step+1;
				}
				path_added = true;
			}
		}
		step++;
	}
	
	cout << "Flag: " << flag_row << " " << flag_col << endl;
	// find path flag
	
	for(unsigned int i=0;i<paths.size();i++)
	{
		for(unsigned int j=0;j<paths[i].size();j++)
		{
			if(_world->EnvMap[i][j] == _world->enimy_flag)
			{
			}
		}
	}
}

void Tank::show_wave(int step, vector< vector<int > > &paths)
{
	cout << "Step " << step << endl;
	for(unsigned int i=0;i<paths.size();i++)
	{
		for(unsigned int j=0;j<paths[i].size();j++)
		{
			cout << setw(3) << paths[i][j] << " ";
		}
		cout << endl;
	}
	cout << endl;
	
	cout << "Press ENTER" << endl;
	char t[10];
	cin.getline(t, 10);
}

int Tank::type()
{
	return OBJ_TANK;
}

void Tank::move_to(int orient)
{
	if(move_info != NULL && ((Orient == ORIENT_UP && orient == ORIENT_DOWN) ||
		(Orient == ORIENT_DOWN && orient == ORIENT_UP) ||
		(Orient == ORIENT_LEFT && orient == ORIENT_RIGHT) ||
		(Orient == ORIENT_RIGHT && orient == ORIENT_LEFT)))
	{
		// stop on opposite movement
		stop();
		return;
	}

	Orient = orient;

	if(move_info != NULL)
	{
		delete move_info;
		move_info = NULL;
	}
	move_info = new MoveInfo(TankSpeed, Orient);

	sprite = _orients[Orient];
	sprite->play(true);

	BBox = _orients_bb[Orient];
}

void Tank::stop()
{
	sprite->set_state(SPRITE_STOP);
	if(move_info != NULL)
	{
		delete move_info;
		move_info = NULL;
	}
}

bool Tank::hit_by(Bullet *b)
{
	if(Armour == 0)
	{
		remove_delay(2000);
		BounceBox b = BBox;
		b.x += X;
		b.y += Y;
		_world->add_explode_area(b, 10);
		BBox = BounceBox();
	}
	else
	{
		Armour--;
		_world->add_explode(b->X, b->Y);
	}
	return true;
}
